import java_cup.runtime.*;
import ast.*;

action code {:
	private NodoBase root=null;
	private NodoBase funciones=null;
	private NodoBase vars=null;
	private boolean debug=true;	
	private int lineaNum=0;

	public NodoBase getRoot(){
		return root;
	}

	public NodoBase getVars(){
		return vars;
	}
	
	public NodoBase getFunciones(){
		return funciones;
	}
:}

/* Simbolos Terminales */

terminal PROGRAM;
terminal BEGIN;
terminal FINPROGRAM;
terminal VAR;
terminal INTEGER;
terminal BOOLEAN;
terminal String IDENTIFICADOR;
terminal String CADENA;
terminal String NUMERO;
terminal IGUAL;
terminal WRITE;
terminal WRITELN;
terminal SUMA;
terminal REST;
terminal MULT;
terminal DIVI;
terminal MOD;
terminal SIGNO;
terminal LPARENT;
terminal RPARENT;
terminal LCORCHE;
terminal RCORCHE;
terminal AND;
terminal OR;
terminal NOT;
terminal COMA;
terminal PTCO;
terminal DOSP;
terminal END;
terminal LINEANUEVA;

/* Simbolos No Terminales */
non terminal NodoBase programaTotal;
non terminal NodoBase declararVariables;
non terminal NodoBase ident;
non terminal NodoBase identAnidado;
non terminal NodoBase seq_sent;
non terminal NodoBase sent;
non terminal NodoBase expresion;
non terminal NodoBase write;
non terminal NodoBase writeAnidado;
non terminal NodoBase writeValor;
non terminal NodoBase separar;
non terminal NodoBase lineas;

precedence left REST, SUMA;
precedence left MULT, DIVI, MOD;
precedence left SIGNO;
precedence left AND, OR;
precedence right NOT;


/* REGLAS GRAMATICALES */
programaTotal ::=
	separar PROGRAM separar IDENTIFICADOR PTCO separar BEGIN separar seq_sent:prog separar FINPROGRAM separar {:
		if(debug)
			System.out.println("\t Regla: programaTotal ::= seq_sent");
		root=prog;
	:}
	| separar PROGRAM separar IDENTIFICADOR PTCO separar declararVariables:var separar BEGIN separar seq_sent:prog separar FINPROGRAM separar {:
		if(debug)
			System.out.println("\t Regla: programaTotal ::= seq_sent");
		root=prog;
		vars=var;
	:}
	| separar {:
		if(debug)
			System.out.println("\t Regla: programaTotal ::= nada ");
	:}
	| error {:
		if(debug)
			System.out.println("\t Regla programaTotal ::= error"); 
		System.out.println("Error: programaTotal ::= NO ENCONTRADA");
	:}
;

declararVariables ::=
	VAR separar identAnidado:identificadores DOSP INTEGER PTCO {:
		if(debug)
			System.out.println("\t Regla: variables ::= VAR separar identAnidado DOSP INTEGER");
		RESULT = new NodoDeclaracion(identificadores,Tipo.Variable.INTEGER);	
	:}
	| VAR separar identAnidado:identificadores DOSP BOOLEAN PTCO {:
		if(debug)
			System.out.println("\t Regla: variables ::= VAR separar identAnidado DOSP BOOLEAN");
		new NodoDeclaracion(identificadores,Tipo.Variable.BOOLEAN);	
	:}
;

identAnidado ::=
	identAnidado:identificadores COMA IDENTIFICADOR:ident {:
		if(debug)
			System.out.println("\t Regla: identAnidado ::= identAnidado COMA IDENTIFICADOR");
		NodoBase hijoActual = identificadores;
		if(hijoActual !=null){
			while(hijoActual.tieneHermano()){
				hijoActual = hijoActual.getHermanoDerecha();
			}
			hijoActual.setHermanoDerecha(new NodoIdentificador(ident));
			RESULT = identificadores;
		}else{
			RESULT = new NodoIdentificador(ident);
		}
	:}
	| IDENTIFICADOR:ident {: 
		if(debug)
			System.out.println("\t Regla: identAnidado ::= IDENTIFICADOR");
		RESULT = new NodoIdentificador(ident);
	:}
;

seq_sent ::=
	seq_sent:sentencias separar sent:sentencia {:
		if(debug)
			System.out.println("\t Regla: seq_sent ::= Varias Sentencias");
		NodoBase hijoActual = sentencias;
		if(hijoActual !=null){
			while(hijoActual.tieneHermano()){
				hijoActual = hijoActual.getHermanoDerecha();
			}
			hijoActual.setHermanoDerecha(sentencia);
			RESULT = sentencias;
		}else{
			RESULT = sentencia;
		}
	:}
	| sent:sentencia {:
		if(debug)
			System.out.println("\t Regla: seq_sent ::= Una Sentencia");
		RESULT = sentencia;
	:}
;

sent ::=
	write:sentencia {:
		if(debug)
			System.out.println("\t Regla: sent ::= write");
		RESULT = sentencia;
	:}
;

write ::=
	WRITE LPARENT writeAnidado:sentencia RPARENT PTCO {:
		if(debug)
			System.out.println("\t Regla: print ::= WRITE writeAnidado");
		RESULT = new NodoEscribir(sentencia,false);
	:}
	| WRITELN LPARENT writeAnidado:sentencia RPARENT PTCO {: 
		if(debug)
			System.out.println("\t Regla: writeAnidado ::= writeAnidado PTCO");
		NodoEscribir nodoEscribir= new NodoEscribir(sentencia,true);
		RESULT = nodoEscribir;
	:}	
;

writeAnidado ::=
	writeAnidado:valores COMA writeValor:valor {:
		if(debug)
			System.out.println("\t Regla: writeAnidado ::= writeAnidado COMA writeValor");
		NodoBase hijoActual = valores;
		if(hijoActual !=null){
			while(hijoActual.tieneHermano()){
				hijoActual = hijoActual.getHermanoDerecha();
			}
			hijoActual.setHermanoDerecha(valor);
			RESULT = valores;
		}else{
			RESULT = valor;
		}
	:}			
	| writeValor:valor {: 
		if(debug)
			System.out.println("\t Regla: writeAnidado ::= writeValor");
		RESULT = valor;
	:}		
;

writeValor ::=
	CADENA:cadena {:
		if(debug)
			System.out.println("\t Regla: writeValor ::= CADENA");
		RESULT = new NodoCadena(cadena.toString());				
	:}
	| expresion:ex {:
		if(debug)
			System.out.println("\t Regla: writeValor ::= expresion");
		RESULT = ex;
	:}
;

expresion ::= 
	NUMERO:num {:
		if(debug)
			System.out.println("\t Regla: expresion ::= NUMERO ");
		RESULT = new NodoNumero(num);
	:}
	| expresion:e1 SUMA expresion:e2 {:
		if(debug)
			System.out.println("\t Regla: expresion ::= SUMA ");
		RESULT = new NodoOperacionMat(e1,e2, Tipo.OpMat.SUMA);
	:}
;

separar ::=
	lineas {: :}
	| {: :}
;

lineas ::=
	lineas LINEANUEVA {: :}
	| LINEANUEVA {: :}
;